"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tabs = Tabs;
exports.Tab = void 0;

var _react = _interopRequireWildcard(require("react"));

var _readline = _interopRequireDefault(require("readline"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _ink = require("ink");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Tab extends _react.Component {
  render() {
    return this.props.children;
  }

}

exports.Tab = Tab;
Tab.propTypes = {
  children: _propTypes.default.node.isRequired,
  name: _propTypes.default.string.isRequired
};

class TabsWithStdin extends _react.Component {
  constructor(props) {
    super(props);
    this.isColumn = this.isColumn.bind(this);
    this.handleTabChange = this.handleTabChange.bind(this);
    this.handleKeyPress = this.handleKeyPress.bind(this);
    this.moveToNextTab = this.moveToNextTab.bind(this);
    this.moveToPreviousTab = this.moveToPreviousTab.bind(this);
    this.state = {
      activeTab: 0
    };
    this.defaultKeyMap = {
      useNumbers: true,
      useTab: true,
      previous: [this.isColumn() ? 'up' : 'left'],
      next: [this.isColumn() ? 'down' : 'right']
    };
  }

  componentDidMount() {
    const {
      stdin,
      setRawMode
    } = this.props; // use ink / node `setRawMode` to read key-by-key

    setRawMode(true);
    stdin.on('keypress', this.handleKeyPress); // select the first tab on component mount

    this.handleTabChange(0);
  }

  componentWillUnmount() {
    const {
      stdin,
      setRawMode
    } = this.props;
    setRawMode(false); // remove set raw mode, as it might interfere with CTRL-C

    stdin.removeListener('keypress', this.handleKeyPress);
  }

  handleTabChange(tabId) {
    const tab = this.props.children[tabId];

    if (!tab) {
      return;
    }

    this.setState({
      activeTab: tabId
    });
    this.props.onChange(tab.props.name, tab);
  }

  handleKeyPress(ch, key) {
    const {
      keyMap
    } = this.props;

    if (!key) {
      return;
    }

    const currentKeyMap = _objectSpread({}, this.defaultKeyMap, keyMap);

    const {
      useNumbers,
      useTab,
      previous,
      next
    } = currentKeyMap;

    if (previous.some(keyName => keyName === key.name)) {
      this.moveToPreviousTab();
    }

    if (next.some(keyName => keyName === key.name)) {
      this.moveToNextTab();
    }

    switch (key.name) {
      case 'tab':
        {
          if (!useTab) {
            return;
          }

          if (true === key.shift) {
            this.moveToPreviousTab();
          } else {
            this.moveToNextTab();
          }

          break;
        }

      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          if (!useNumbers) {
            return;
          }

          if (true === key.meta) {
            const tabId = '0' === key.name ? 9 : parseInt(key.name, 10) - 1;
            this.handleTabChange(tabId);
          }
        }

      default:
        return;
    }
  }

  isColumn() {
    const {
      flexDirection
    } = this.props;
    return flexDirection === 'column' || flexDirection === 'column-reverse';
  }

  moveToNextTab() {
    let nextTabId = this.state.activeTab + 1;

    if (nextTabId >= this.props.children.length) {
      nextTabId = 0;
    }

    this.handleTabChange(nextTabId);
  }

  moveToPreviousTab() {
    let nextTabId = this.state.activeTab - 1;

    if (nextTabId < 0) {
      nextTabId = this.props.children.length - 1;
    }

    this.handleTabChange(nextTabId);
  }

  render() {
    const _this$props = this.props,
          {
      children,
      onChange,
      flexDirection
    } = _this$props,
          rest = _objectWithoutProperties(_this$props, ["children", "onChange", "flexDirection"]);

    const separatorWidth = rest.width || 6;
    const separator = this.isColumn() ? new Array(separatorWidth).fill('â”€').join('') : ' | ';
    return _react.default.createElement(_ink.Box, _extends({
      flexDirection: flexDirection
    }, rest), children.map((child, key) => {
      const {
        name
      } = child.props;
      return _react.default.createElement(_ink.Box, {
        key: name,
        flexDirection: flexDirection
      }, key !== 0 && _react.default.createElement(_ink.Color, {
        dim: true
      }, separator), _react.default.createElement(_ink.Box, null, _react.default.createElement(_ink.Color, {
        keyword: "grey"
      }, key + 1, ". "), _react.default.createElement(_ink.Color, {
        bgGreen: this.state.activeTab === key,
        black: this.state.activeTab === key
      }, child)));
    }));
  }

}

TabsWithStdin.defaultProps = {
  flexDirection: null
};
TabsWithStdin.propTypes = {
  setRawMode: _propTypes.default.func.isRequired,
  stdin: _propTypes.default.object.isRequired,
  onChange: _propTypes.default.func.isRequired,
  children: _propTypes.default.node.isRequired,
  flexDirection: _propTypes.default.string,
  keyMap: _propTypes.default.shape({
    useNumbers: _propTypes.default.bool,
    useTab: _propTypes.default.bool,
    previous: _propTypes.default.arrayOf(_propTypes.default.string),
    next: _propTypes.default.arrayOf(_propTypes.default.string)
  })
};

function Tabs(props) {
  return _react.default.createElement(_ink.StdinContext.Consumer, null, ({
    stdin,
    setRawMode
  }) => _react.default.createElement(TabsWithStdin, _extends({
    stdin: stdin,
    setRawMode: setRawMode
  }, props)));
}
